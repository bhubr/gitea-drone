# Playbook modifié pour Gitea 1.16
---
- name: Gitea
  hosts:
    - gitea_new
  become: true
  tasks:
    - name: Disable 3.15/main repo in /etc/apk/repositories
      lineinfile:
        dest: /etc/apk/repositories
        regexp: '^(https?:\/\/[^/]*)\/v3\.15\/main.*$'
        line: '#\1/v3.15/main\n'
        backrefs: yes
    - name: Enable edge/main repo in /etc/apk/repositories
      lineinfile:
        dest: /etc/apk/repositories
        regexp: '^#(https?:\/\/([^/]*))\/edge\/main.*$'
        line: '\1/edge/main'
        state: present
        backrefs: yes
    - name: Enable edge/community repo in /etc/apk/repositories
      lineinfile:
        dest: /etc/apk/repositories
        regexp: '^#(https?:\/\/([^/]*))\/edge\/community.*$'
        line: '\1/edge/community'
        state: present
        backrefs: yes

    # # Ansible peut rencontrer des problèmes s'il ne peut
    # # utiliser un shell Bash sur les "managed hosts"
    # # En plus de Bash, on installe Gitea (forge logicielle)
    # # et SQLite (Gitea peut s'en passer car il intègre
    # # dans son fichier exécutable la bibliothèque SQLite,
    # # mais on utilisera ce dernier pour vérifier des choses
    # # dans la base de données)
    - name: Install Bash, Gitea and SQLite
      apk:
        name:
          - bash
          - gitea
          # - sqlite
        update_cache: yes
    # # Le service doit être stoppé (state=stopped)
    # # avant d'effectuer des modifications,
    # # mais sera démarré au reboot (enabled=yes)
    - name: Make sure Gitea is NOT started
      service:
        name: gitea
        state: stopped
        enabled: yes
    # # Gitea utilise une base de données SQLite3, laquelle
    # # est entièrement contenue dans un simple fichier
    # # (gitea.db). On vérifie si le fichier existe avec stat,
    # # et enregistre le résultat comme variable.
    - name: Check if Gitea SQLite3 database exists
      stat: path=/var/lib/gitea/db/gitea.db
      ignore_errors: true
      register: gitea_db
    # # Utilisation du when pour ne créer la BDD que si
    # # elle n'existe pas encore
    - name: Create gitea database
      shell: |
        sudo -u gitea gitea migrate \
        --config /etc/gitea/app.ini
      when: gitea_db.stat.exists == false
    # # Gitea stocke sa configuration dans le fichier app.ini
    # # Lorsqu'on l'installe "normalement" (de façon non-automatisée),
    # # on doit valider les paramètres via une page web.
    # # Insérer la ligne INSTALL_LOCK=true, si elle n'existe pas,
    # # permet de passer cette étape.
    - name: Insert INSTALL_LOCK to bypass web-based install
      lineinfile:
        path: /etc/gitea/app.ini
        regexp: '^INSTALL_LOCK'
        insertafter: '^INTERNAL_TOKEN.*'
        line: 'INSTALL_LOCK=true'
    # # Ici, on exécute directement une requête SQL en ligne
    # # de commande, sur la BDD contenue dans gitea.db,
    # # afin de récupérer le nombre d'utilisateurs existants.
    - name: List Gitea users
      shell: sudo -u gitea gitea admin user list
      register: gitea_list_users
    - debug: gitea_list_users
    # # - name: Check that admin user exists
    # #   shell: |
    # #     sqlite3 \
    # #       /var/lib/gitea/db/gitea.db \
    # #       'select count(*) from user;'
    # #   register: gitea_count_users
    # # - debug: var=gitea_count_users
    # # # On crée un utilisateur "admin", sauf si la tâche précédente
    # # # a renvoyé une valeur de '1' dans gitea_count_users.stdout
    # # - name: Create gitea admin user
    # #   shell: |
    # #     sudo -u gitea gitea admin user create --admin \
    # #     --username root \
    # #     --password root1234 \
    # #     --email root@gitea.tls
    # #   when: gitea_count_users.stdout != '1'
    # # # Gitea étant configuré, on peut le démarrer
    # # - name: Make sure Gitea is started
    # #   service:
    # #     name: gitea
    # #     state: started
    # #     enabled: yes
